@EnableAsync与@Async注解  的理论

需要ThreadPoolExecutor代替Executor，避免Executor的缺点

Future`/`CompletableFuture` 的理论

事务失效 @Transactional失效  的理论   注解式与编程式的区别

TinyId 分布式ID

项目难点：注册验证码  数据库，redis，分布式锁，事务，MQ+task表做异步补偿，布隆过滤器



Lua脚本 与redis



数据库（db）和缓存（Cache）数据不一致的问题

8.1 数据库（db）和缓存（Cache）数据不一致的问题,主要是以后从缓存读都是脏数据（讲概率，比的是会不一致的时间） 缓存的写入与读取速度是比数据库的写入与读取速度快很多

## 旁路缓存

读操作

1. 先查缓存
2. 如果命中，直接返回
3. 如果未命中，查数据库，并把结果写入缓存

写操作

1. 先更新数据库
2. 然后删除或更新缓存（推荐删除更安全）（**写操作比较频繁**，且验证码属于热点数据与数据库和缓存数据强一致场景，放入 cache）



**缺陷 1：首次请求数据一定不在 cache 的问题**

解决办法：可以将热点数据可以提前放入 cache 中。

**缺陷 2：写操作比较频繁的话导致 cache 中的数据会被频繁被删除，这样会影响缓存命中率 。**

解决办法：

* 数据库和缓存数据强一致场景：更新 db 的时候同样更新 cache，不过我们需要加一个锁/分布式锁来保证更新 cache 的时候不存在线程安全问题。
* 可以短暂地允许数据库和缓存数据不一致的场景：更新 db 的时候同样更新 cache，但是给缓存加一个比较短的过期时间，这样的话就可以保证即使数据不一致的话影响也比较小。


（先更新数据库，后删除redis：

先写后读：数据库更新完到redis删除结束这段时间，不是第一次读，从redis读的是脏数据；是第一次读，没事；

先读后写：不是第一次读，读到旧数据；是，读到数据库还未更新完的数据，写更新数据库，读如果在删除redis前写入redis，这段时间为脏数据；删除redis后写入redis，则以后从redis读为脏数据；（读此时写入缓存，写更新完数据库+删除缓存，读操作要在写操作后面，概率小，平均大概为缓存写入与读取速度/数据库写入与读取速度）

![先更新数据库再删缓存](https://developer.qcloudimg.com/http-save/yehe-11320052/33afe01dd40da311ef6e8d7d1e74f6db.png)

先删除redis，后更新数据库：

先写后读：redis删除完到数据库更新结束这段时间，从数据库读的是脏数据，而且会写入redis脏数据，以后从redis读也是脏数据 （更新数据库时间读到数据库还未更新完的数据）

先读后写：在redis删除前从redis读，旧数据，非脏数据）

![先删缓存，再更新数据库](https://developer.qcloudimg.com/http-save/yehe-11320052/ec981ddb0706bbd85efe0d086fb49548.png)

## 延迟双删

### 先删缓存，再更新数据库，延迟一段时间后再删一次缓存

![第一种延迟双删策略](https://developer.qcloudimg.com/http-save/yehe-11320052/59dd3db027d733e2c28cd4cb7e1181d0.png)

### 先更新数据库，再删缓存，延迟一段时间后再删一次缓存

![第二种延迟双删策略](https://developer.qcloudimg.com/http-save/yehe-11320052/8b680833f95112a5e62aa3e5503c3095.png)
