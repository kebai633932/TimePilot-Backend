1. 实现：用逻辑删除后可注册同名用户 &&  用户注册事务处理，解决并发问题

问题：**用逻辑删除后可注册同名用户，那“用户名唯一性校验”，**经典陷阱**：**逻辑删除的用户仍然可能阻止新用户注册相同用户名**，或者**导致唯一索引冲突**

最终方案：(user_name, is_del, del_version)唯一索引兜底+redis分布式锁（锁粒度按用户名）并发控制，确保最终一致性

is_del按Java通用开发手册，取值范围为0,1

参考：mybatisplus的方法：将逻辑删除字段改为时间类型  或者  (user_name, is_del, del_version) 符合数据库范式

其他方案：**分离表方案**（活跃/历史数据分表存储，跨表操作的原子性与**删除时间**）；

2.用户通过账号+密码登录系统，获取 Access Token 和 Refresh Token，用于后续身份验证。

流程图：

![image.png](assets/image2.png)

经分析[有缓存穿透的风险：用redis做布隆过滤器](https://)（**布隆过滤器可以判断某个数据一定不存在，但是无法判断一定存在**。）

布隆过滤器：一种数据结构，是由一串很长的二进制向量组成，可以将其看成一个二进制数组。

向布隆过滤器中添加一个元素key时，我们通过多个hash函数，算出一个值，然后将这个值所在的方格置为1。

　　优点：优点很明显，二进制组成的数组，占用内存极少，并且插入和查询速度都足够快。

　　缺点：随着数据的增加，误判率会增加；还有无法判断数据一定存在；另外还有一个重要缺点，无法删除数据。

3.首次使用系统时创建账号（含密码复杂度校验），需邮箱验证码验证，创建成功后可直接登录或跳转登录流程。

```
用户名不合法：只能包含中英文、数字、下划线，长度3-20
密码必须包含大写字母、小写字母、数字，且长度至少8位
```

3.1 注册接口中多个用户同时注册同一个用户名时：

* 先用 Redis 分布式锁锁住该用户名
* 只有获得锁的请求能操作数据库
* 其他请求等待或失败，避免数据库重复写入导致唯一索引冲突

3.2 在 **发送邮件流程中，`JavaMailSender.send(...)` 的网络 IO 是最主要的耗时瓶颈**  用异步处理

方案：1.@EnableAsync与@Async注解  2.消息队列（MQ） 3. `Future`/`CompletableFuture`

1.缺点：**

* 异步方法抛出的异常，默认情况下不会传播到调用者，需要额外的异常处理机制来捕获和处理。**﻿**
* **Spring AOP代理限制:**
* `@Async`注解依赖于Spring AOP的代理机制，因此有一些限制：如果方法是`private`、`static`或`final`，或者类本身没有被Spring管理，`@Async`注解会失效；方法内部调用自身，不会触发异步代理，需要通过`ApplicationContext`获取代理对象才能实现。**﻿**
* 默认：SimpleAsyncTaskExecutor，不是真的线程池，这个类**不重用线程，每次调用都会创建一个新的线程，没有最大线程数设置。** **并发大的时候会产生严重的性能问题**。
* Spring 的事务管理依赖于线程局部变量（ThreadLocal）存储事务状态。而 `@Async` 会把这个方法丢给线程池中的**另一个线程去执行**，这个线程没有事务上下文（也就是没有开启事务），就不能回滚或参与外层事务了。

2.暂时不需要支持重试机制与持久化

![image.png](assets/image1.png)

3.ThreadPoolExecutor加CompletableFuture

重试5次：指数回退 + 抖动（Exponential Backoff with Jitter）是网络和分布式系统中非常常见的重试策略

* **指数回退的作用：**
  通过不断拉长重试间隔，减少重试请求频率，给系统“喘息”的时间。网络或服务故障往往是暂时的，指数回退让请求延迟加长，能更好等待系统恢复，提高重试成功的概率。
* **抖动的作用：**
  抖动是在指数回退的基础上再加上一个随机时间，防止所有客户端或线程在同一时间点同步发起重试，从而进一步避免请求瞬间集中。加抖动后，更均匀分布重试请求，避免碰巧所有请求又撞上系统负载峰值。

4.注册，删除等用户动作  都需要同步添加用户角色表（简单添加）写两个表，用事务保证（编程式事务）    （注意事务失效，事务的配置）

5.注册流程用redis的分布式锁做用户名的加锁处理： redis不可用降级，直接让请求通过，数据库中(user_name, is_del（默认0）, del_version（默认0）)唯一索引兜底 （失败的，过度工程化，已经做了）

6.redis不可用（qps低，用不到）：这时redis集群（主从）一定的，处理策略：

**失败中止策略**：直接返回错误提示（如“系统繁忙，请稍后重试”）

**降级容忍策略**：允许系统继续注册流程，转由数据库兜底处理

验证码放redis的降级处理：选择数据库做验证码表来兜底；本地缓存（Caffeine）降级 + 分布式架构配合（“同源绑定”（也叫“会话粘性”或“会话保持”）是指让**同一个用户的请求和验证都路由到同一台服务器节点**，确保本地缓存的数据一致性。缺点：有单点故障风险，影响负载均衡均匀性，可能导致某节点压力大））

7.验证码防攻击策略：随机过期，防redis大量缓存同一时间失效

8.短信，邮件防刷限流

灰度限流降级（Sentinel + 自定义策略）部分直接提示“系统繁忙，请稍后再试”

使用：Spring AOP + Redis Lua 限流。SETEX 间隔锁 实现频率间隔； ZSet（ZADD + ZREMRANGE） 滑动窗口 实现超过每小时数量限制放入黑名单；Set（SADD）做黑名单；`INCR` + `EXPIREAT`做系统总量限制

9.忘记密码

10.退出


| 问题     | 原因                               | 防御方法                         |
| -------- | ---------------------------------- | -------------------------------- |
| 缓存穿透 | 缓存无数据且请求不存在的数据       | 缓存空结果、布隆过滤器、参数校验 |
| 缓存击穿 | 热点数据失效，瞬间大量请求击穿缓存 | 互斥锁、逻辑过期、缓存预热       |
| 缓存雪崩 | 大量缓存同一时间失效               | 随机过期、限流降级、多级缓存     |
