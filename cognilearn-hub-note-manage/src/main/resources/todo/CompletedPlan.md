先考虑性能，再考虑架构   ddd解决

业务逻辑集中在领域模型

* 聚合根（Aggregate Root）和实体（Entity）承载业务规则。
* Controller/Service 不再直接操纵数据库表，而是操作领域对象。

**边界清晰（Bounded Context）**

* 系统按业务模块划分上下文，减少模块间耦合。
* 比如“订单上下文”只关心订单业务，“库存上下文”只关心库存业务。

各层直接通过接口解耦，触发层Controller → 应用服务层Application Service → 领域层 Domain Service →基础设施层 Repository → ORM/DB

### **最小化锁与事务范围**

* 事务越大 → 持锁时间越长 → 并发性能越差。
* 优先在 **仓储层（Repository）** 控制事务（单表 / 单聚合根级别的原子操作）。
* **仓储层事务 > 应用层事务**（粒度更细）。
* **事务与锁范围越小越好**（性能优先）。

1. 笔记列表   读笔记，写笔记（标题，父节点），文件夹（父节点，名称）

特点：读写比较均衡，甚至略偏写，数据轻量，不需要多端同步，读用设计，最开始全部存入前端缓存，后面结构变更，同步前端，应该多是重新加载场景，改完后读少写多

* **读取列表**：一次性获取用户所有笔记，包括所有文件夹、笔记名称和父节点信息
* **多端同步**：不需要
* **写操作**：相对频繁
* **列表数据量**：可能中等偏大（ID + 名称 + 父节点）

列表页不需要严格实时同步，短延迟即可满足用户体验

* **普通 Cache-Aside** 足够：
  * 写数据库 → 删除缓存
  * 下次访问列表页 → 缓存回填
  * 简单实现，最终一致性可控
* **延迟双删** 主要是为了解决 **高并发写 + 高频读** 时缓存可能被旧数据覆盖的问题
  * 你这里列表访问低频 → 不必要，删除缓存一次就够

前端后端都需要做缓存

1. **缓存设计（参考粒度拆分）**   **频繁变动且顺序重要的列表缓存 → 直接更新**； **单条信息或轻量属性 → 删除 Key，下次访问回填**

**推荐策略**：list缓存 相对写操作频繁

* **写操作不特别频繁 → 删除 Key，下次访问回填即可**
  * 实现简单，最终一致性可控
* **如果写操作频繁且列表/单条信息访问很频繁 → 直接更新缓存更优**
  * 需要在写数据库时顺便更新缓存，保证缓存命中率和前端显示一致


| 缓存 Key                    | 内容                            | 更新策略                                             |
| --------------------------- | ------------------------------- | ---------------------------------------------------- |
| `user:{userId}:note:list`   | 用户笔记 ID 列表                | 笔记新增/删除→ 删除此 Key，下次访问回填             |
| `note:{noteId}:info`        | `{title, folderId, updateTime}` | 笔记改名/改父节点/删除 → 删除此 Key，下次访问回填   |
| `folder:{folderId}:info`    | `{name, parentId, updateTime}`  | 文件夹改名/改父节点/删除 → 删除此 Key，下次访问回填 |
| `user:{userId}:folder:list` | 用户文件夹 ID 列表              | 文件夹新增/删除→ 删除此 Key，下次访问回填           |

2. 高并发下文件夹的增删改，事务与锁  树高（写前读），缓存   当前选择：用户级锁     高并发：  目录级锁（祖先锁）

文件夹树高（h）最多为5，读写比较均衡，甚至略偏写，邻接表（Adjacency List）存储高效，

修改    增加O(h) O(1) 不嵌套删除O(1) O(1)         嵌套删除（不做） O(hm) O(m)

应用层bfs  修改 因为需要判断树高O(hm) O(n1) m为子树单层最多节点数，n1为子树节点数   h次sql查询   in 数据量小时，索引不失效  需要查子树文件夹

数据库维护 \`path \` 字段     O(n1)  **O**(**n**1)  n1为子树所有文件夹数   2次sql查询（LIKE 'A_path/%'，索引不失效），2次批量sql修改    需要查，修改子树文件夹与笔记

一次 SQL 获取完整向上或向下链路（或用递归 CTE） 向上查祖先链（单路径）O(h) O(h) 向下查子孙（整棵子树）  O(m \* h) O(m \* h)  1次sql查询  时间空间都是在数据库

三个的时间空间复杂度一样

数据库资源最紧张、高并发或子树节点多 → 多次调用应用层递归更稳  高并发 + 大子树 → **多次小查询，分散压力，更稳**

数据库资源充足、子树规模适中、读多写少 → SQL 递归/CTE 性能更好   一次性递归 CTE，SQL 少，性能高


| 方案           | 数据库峰值         | SQL次数             | 适合场景                           |
| -------------- | ------------------ | ------------------- | ---------------------------------- |
| 应用层递归     | 低峰值，分散       | 多次（按层）        | 高并发、大用户数、小子树           |
| SQL 递归 / CTE | 高峰值，一次性     | 1 次                | 中小子树、读多写少、数据库资源足   |
| path 字段维护  | 峰值集中在批量更新 | 少量查询 + 批量更新 | 大子树、读多写少、事务一致性要求高 |

一次性加载整个用户的文件夹树 + 内存计算（缓存）  O(n)  **O**(**n**)   n为用户所有文件夹数    1次sql查询    淘汰，其他都是子树节点数，这是用户节点数

数据库维护 `depth` 字段（或嵌套集合模型 Nested Set）   要维护子树深度，嵌套像应用层递归

4. **「读依赖」(read-before-write)** 或 **「读校验」**    **写操作中涉及的读操作** → 必须读数据库（事务内）
5. 文件夹：增删查，改（内容，上级文件夹）  不会成环，树形结构（树高最多为3，现在只有全部一次查询，多是插入，移动，删除节点）：邻接表，闭包表

## 邻接表（Adjacency List）

### 特点

1. **简单直观**：每个节点只存储直接父节点的引用
2. **存储高效**：每节点只需一行数据
3. **操作简单**：
   * 插入：只需插入新节点并设置parent\_id
   * 移动：只需更新parent\_id
   * 删除：需递归删除子节点
4. **查询限制**：
   * 查询子树需要递归操作
   * 查询路径需要递归操作
   * 查询深度需要递归计算

### 适用场景

* 层级固定且较浅的树（如最大深度3的文件夹结构）
* 写操作频繁，读操作较少的场景
* 不需要频繁查询完整子树或路径的系统

## 闭包表（Closure Table）

### 特点

1. **冗余存储**：存储所有祖先-后代关系
2. **查询高效**：
   * 查询子树：`SELECT * FROM folders WHERE id IN (SELECT descendant FROM folder_paths WHERE ancestor = ?)`
   * 查询路径：`SELECT * FROM folders WHERE id IN (SELECT ancestor FROM folder_paths WHERE descendant = ?)`
   * 查询深度：`SELECT depth FROM folder_paths WHERE ancestor = ? AND descendant = ?`
3. **操作复杂**：
   * 插入：需添加自身路径和所有祖先路径
   * 移动：需删除旧路径，添加新路径
   * 删除：需删除所有相关路径
4. **存储开销**：每节点存储多行路径数据（O(n)空间）

### 适用场景

* 层级深度不确定或很深的树结构
* 需要频繁查询子树、路径或深度的系统
* 读操作频繁，写操作较少的场景
* 需要高性能树形查询的应用

6. 笔记增删改需要父文件夹存在

* 文件夹操作还是 `userId` 锁（保持目录树一致性）。
* 笔记操作改为 `folderId` 锁（只关心父目录是否有效）。删除文件夹会检查下级是否有文件与文件夹
* 删除文件夹时会同时拿到 `userId` 锁与`folderId` 锁 → 避免并发创建笔记。

7. markdown格式变成纯文本

**commonmark-java + Jsoup** 的标准做法，保证 Markdown 渲染准确，最后再用 Jsoup 去掉 HTML 标签拿到纯文本



8. Markdown 编辑器一般支持监听 `paste` 事件。前端可以在事件里检测剪贴板内容  后端上传京东OSS
