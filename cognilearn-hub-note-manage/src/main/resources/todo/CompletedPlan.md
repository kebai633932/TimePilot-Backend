1. 笔记列表   读笔记，写笔记（标题，父节点），文件夹（父节点，名称）

特点：读少写多，数据轻量，不需要多端同步，读应该多是重新加载场景

* **读取列表**：一次性获取用户所有笔记，包括所有文件夹、笔记名称和父节点信息
* **多端同步**：不需要
* **写操作**：相对频繁
* **列表数据量**：可能中等偏大（ID + 名称 + 父节点）

列表页不需要严格实时同步，短延迟即可满足用户体验

* **普通 Cache-Aside** 足够：
  * 写数据库 → 删除缓存
  * 下次访问列表页 → 缓存回填
  * 简单实现，最终一致性可控
* **延迟双删** 主要是为了解决 **高并发写 + 高频读** 时缓存可能被旧数据覆盖的问题
  * 你这里列表访问低频 → 不必要，删除缓存一次就够

前端后端都需要做缓存

1. **缓存设计（参考粒度拆分）**   **频繁变动且顺序重要的列表缓存 → 直接更新**； **单条信息或轻量属性 → 删除 Key，下次访问回填**

**推荐策略**：list缓存 相对写操作频繁

* **写操作不特别频繁 → 删除 Key，下次访问回填即可**
  * 实现简单，最终一致性可控
* **如果写操作频繁且列表/单条信息访问很频繁 → 直接更新缓存更优**
  * 需要在写数据库时顺便更新缓存，保证缓存命中率和前端显示一致


| 缓存 Key                    | 内容                            | 更新策略                                             |
| --------------------------- | ------------------------------- | ---------------------------------------------------- |
| `user:{userId}:note:list`   | 用户笔记 ID 列表                | 笔记新增/删除→ 删除此 Key，下次访问回填             |
| `note:{noteId}:info`        | `{title, folderId, updateTime}` | 笔记改名/改父节点/删除 → 删除此 Key，下次访问回填   |
| `folder:{folderId}:info`    | `{name, parentId, updateTime}`  | 文件夹改名/改父节点/删除 → 删除此 Key，下次访问回填 |
| `user:{userId}:folder:list` | 用户文件夹 ID 列表              | 文件夹新增/删除→ 删除此 Key，下次访问回填           |

2. 高并发下文件夹的增删改，事务与锁  树高（写前读，应用层循环，不用递归CTE优化），缓存   当前选择：用户级锁     高并发：  目录级锁（祖先锁）
3. **「读依赖」(read-before-write)** 或 **「读校验」**    **写操作中涉及的读操作** → 必须读数据库（事务内）
4. 文件夹：增删查，改（内容，上级文件夹）  不会成环，树形结构（树高最多为3，现在只有全部一次查询，多是插入，移动，删除节点）：邻接表，闭包表

## 邻接表（Adjacency List）

### 特点

1. **简单直观**：每个节点只存储直接父节点的引用
2. **存储高效**：每节点只需一行数据
3. **操作简单**：
   * 插入：只需插入新节点并设置parent\_id
   * 移动：只需更新parent\_id
   * 删除：需递归删除子节点
4. **查询限制**：
   * 查询子树需要递归操作
   * 查询路径需要递归操作
   * 查询深度需要递归计算

### 适用场景

* 层级固定且较浅的树（如最大深度3的文件夹结构）
* 写操作频繁，读操作较少的场景
* 不需要频繁查询完整子树或路径的系统


## 闭包表（Closure Table）

### 特点

1. **冗余存储**：存储所有祖先-后代关系
2. **查询高效**：
   * 查询子树：`SELECT * FROM folders WHERE id IN (SELECT descendant FROM folder_paths WHERE ancestor = ?)`
   * 查询路径：`SELECT * FROM folders WHERE id IN (SELECT ancestor FROM folder_paths WHERE descendant = ?)`
   * 查询深度：`SELECT depth FROM folder_paths WHERE ancestor = ? AND descendant = ?`
3. **操作复杂**：
   * 插入：需添加自身路径和所有祖先路径
   * 移动：需删除旧路径，添加新路径
   * 删除：需删除所有相关路径
4. **存储开销**：每节点存储多行路径数据（O(n)空间）

### 适用场景

* 层级深度不确定或很深的树结构
* 需要频繁查询子树、路径或深度的系统
* 读操作频繁，写操作较少的场景
* 需要高性能树形查询的应用
